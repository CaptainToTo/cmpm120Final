// root Placeable class inherited by all classes describing placable objects
// generated by conveyer belt

// root class describes basics animations and behaviors

let placeablesIDs = 0;

class Placeable {
    constructor(scene, x, y, sprite, belt, stretch=1) {
        this.sprite = scene.matter.add.sprite(x, y, sprite).setOrigin(0.5, 0.5);
        this.sprite.body.isStatic = true;
        this.sprite.setCollisionCategory(0x0000);
        this.source = sprite; // the source image string
        this.scene = scene;

        this.objectType = "Placeable"; // sub classes will replace this string with their own unique type

        this.belt = belt; // reference to the belt object to remove self from belt list 
        this.bound = belt.sprite.y + (belt.sprite.height / 2);  // dead zone for placing object, if object is still on conveyer belt do not drop

        this.originalScale = 1; // original scale for keeping animations consistent
        this.stretch = stretch; // scale to change to when object is placed
        this.setScale(0.5);

        this.placed = false;    // tracks if object has been placed
        this.grabbed = false;   // player is currently placing object
        this.saved = false;     // if object was placed in a previous run, previous duplicate saves

        // on interaction animations
        let self = this;
        this.sprite.setInteractive()
            .on("pointerover", () => { // stretch when hovered over
                if (!self.placed && !self.grabbed) {
                    scene.tweens.add({
                        targets: self.sprite,
                        scale: self.originalScale + (self.originalScale * 0.1),
                        duration: 150
                    })
                }
            })
            .on("pointerout", () => { // shrink back to original size when mouse is taken off
                if (!self.placed) {
                    scene.tweens.add({
                        targets: self.sprite,
                        scale: self.originalScale,
                        duration: 150
                    })
                }
            })
            .on("pointerdown", () => { // pickup and follow
                if (!self.placed) {
                    self.grabbed = true;
                }
            })
            .on("pointerup", () => { // drop object
                if (!self.placed) {
                    self.grabbed = false;
                    if (self.sprite.y > self.bound) {
                        self.Place(); // add physics
                    } else {
                        belt.fixPosition(self); // fix position, put back in order on conveyer belt
                    }
                }
            });
        
        // if object is grabbed, follow mouse
        scene.input.on('pointermove', function(pointer) {
            if (self.grabbed) {
                self.sprite.x = pointer.x;
                self.sprite.y = pointer.y;
            }
        });
    }

    // drop object into physics
    Place() {
        this.placed = true;

        this.belt.removeObject(this); // remove from conveyer belt
        this.sprite.body.isStatic = false; // add sprite to physics
        this.sprite.setCollisionCategory(this.scene.floorLayer);
        this.scene.placed.push(this); // add self to scene's list of placed objects
    }

    // changes sprite scale and originalScale
    setScale(scale) {
        this.sprite.setScale(scale);
        this.originalScale = scale;
    }

    // returns a json object version of the placeable instance
    JSON() {
        const obj = {
            objectType: this.objectType,
            id: this.id,
            y: this.sprite.y,
            x: this.scene.progress - (this.scene.objSpawn - this.sprite.x),
            rotation: this.sprite.rotation
        };

        return obj;
    }
}

// bomb
class Bomb extends Placeable {
    constructor(scene, x, y, belt, stretch=2) {
        super(scene, x, y, "bomb", belt, stretch);
        this.objectType = "Bomb";
    }

    Place() {
        super.Place();
        this.sprite.body.isStatic = true;

        // check for collisions
        for (let i = 0; i < this.scene.boxQueue.length; i++) {
            const col = Matter.SAT.collides(this.sprite.body, this.scene.boxQueue[i].sprite.body);

            if (col) {
                if (this.scene.boxQueue[i].objectType == "Bedrock") continue;
                // TODO: exploding animation
                this.scene.boxQueue[i].Demolish();
                break;
            }
        }
        
        // destroy
        this.scene.time.delayedCall( 500, () => {
            this.scene.removeObject(this.scene.placed.indexOf(this));
        });
    }
}

// water bucket
class WaterBucket extends Placeable {
    constructor(scene, x, y, belt, stretch=2) {
        super(scene, x, y, "waterbucket", belt, stretch);
        this.objectType = "WaterBucket";
    }

    Place() {
        super.Place();
        this.sprite.body.isStatic = true;
        
        // check for collisions with blocks
        for (let i = 0; i < this.scene.boxQueue.length; i++) {
            const col = Matter.SAT.collides(this.sprite.body, this.scene.boxQueue[i].sprite.body);
            
            if (col) {
                if (this.scene.boxQueue[i].objectType == "Bedrock") continue;
                // TODO: weathering animation
                this.scene.boxQueue[i].Weather();
                break;
            }
        }
        
        // destroy
        this.scene.time.delayedCall( 500, () => {
            // remove object from placed list
            this.scene.removeObject(this.scene.placed.indexOf(this));
        });
    }
}


// jump pad
class JumpPad extends Placeable {
    constructor(scene, x, y, belt, stretch) {
        super(scene, x, y, "jumppad", belt, stretch);
        this.objectType = "JumpPad";
        this.origY = y; // used to check if placeable has moved

        // change hitbox
        this.sprite.body.vertices[0].y += (this.sprite.height/2) * 0.5;
        this.sprite.body.vertices[0].x += (this.sprite.width/1.5) * 0.5;

        this.sprite.body.vertices[1].y += (this.sprite.height/2) * 0.5;
        //this.sprite.body.vertices[1].x -= (this.sprite.width/2) * 0.5;

        this.sprite.setMass(50);
    }

    Place() {
        super.Place();
        if (!this.saved) {
            this.id = placeablesIDs;
            placeablesIDs += 1;
            // save object
            this.scene.pList.Insert(this);
        }

        this.scene.tweens.add({
            targets: this.sprite,
            scale: this.stretch,
            duration: 200
        });

        let self = this;
        this.scene.matter.world.on('collisionstart', (event, bodyA, bodyB) =>{
            if ((bodyA == self.sprite.body && bodyB == self.scene.player.frontWheel.body) ||
                (bodyB == self.sprite.body && bodyA == self.scene.player.frontWheel.body)) {
                    self.scene.player.frontWheel.setVelocity(50, -10);
            }
        })

        this.scene.time.delayedCall(200, this.setScale(this.stretch));
    }
}

// specific maker for jump pad object
function JumpPadMaker(scene, jsonObj) {
    let obj = new JumpPad(scene, scene.objSpawn, jsonObj.y, scene.belt);
    obj.id = jsonObj.id;
    obj.sprite.rotation = jsonObj.rotation;
    obj.saved = true;
    obj.Place();
    obj.saved = false;

    return obj;
}

// ramp up
class Ramp extends Placeable {
    constructor(scene, x, y, belt, stretch) {
        super(scene, x, y, "ramp", belt, stretch);
        this.objectType = "Ramp";
        this.origY = y; // used to check if placeable has moved
        // change hitbox to triangle
        this.sprite.body.vertices.splice(0, 1);
    }

    Place() {
        super.Place();
        if (!this.saved) {
            this.id = placeablesIDs;
            placeablesIDs += 1;
            // save object
            this.scene.pList.Insert(this);
        }

        this.scene.tweens.add({
            targets: this.sprite,
            scale: this.stretch,
            duration: 200
        });

        this.scene.time.delayedCall(200, this.setScale(this.stretch));
    }
}

// specific maker for ramp object
function RampMaker(scene, jsonObj) {
    let obj = new Ramp(scene, scene.objSpawn, jsonObj.y, scene.belt);
    obj.id = jsonObj.id;
    obj.sprite.rotation = jsonObj.rotation;
    obj.saved = true;
    obj.Place();
    obj.saved = false;

    return obj;
}


// Block
class Block extends Placeable {
    constructor(scene, x, y, belt, stretch) {
        super(scene, x, y, "bedrock", belt, stretch);
        this.objectType = "Block";
        this.origY = y; // used to check if placeable has moved, not used?
    }

    Place() {
        super.Place();
        this.sprite.body.isStatic = true;
        if (!this.saved) {
            this.id = placeablesIDs;
            placeablesIDs += 1;
            // save object
            this.scene.pList.Insert(this);
        }
    }
}

// specific maker for ramp object
function BlockMaker(scene, jsonObj) {
    let obj = new Block(scene, scene.objSpawn, jsonObj.y, scene.belt);
    obj.id = jsonObj.id;
    obj.sprite.rotation = jsonObj.rotation;
    obj.saved = true;
    obj.Place();
    obj.saved = false;

    return obj;
}